# This file is part of DocBook NG: The "Absinthe" Release.

# This schema is a "work-in-progress". It validates a DocBook-like grammar that
# may, in some incarnation, form the basis for DocBook V.next. Or it may not.
# At the moment, it's just an exploration by Norm. It has utterly no normative
# value at all.
#
# Author: Norman Walsh, <ndw@nwalsh.com>
# Source: Derived from DocBook XML V4.3
# Release: $Id$
#

# TEI:
#
# addrPart = address contents
# agent = individuals or corporations?
# bibl = bibliographic items
# biblPart = contents of a bibliographic item
# inter = things that can appear between or within chunks
# chunk = blocks that can't contain themselves (contains para)
# common = chunk and inter (things in all bases)
# data = inline names, dates, numbers, measures, etc.
#        (abbr, address, date, daterange, datestruct, expan, geogname, ...)
# date = date expressions
# demographic = elements describing demographics in a linguistic context
#               (used person and persongroup)
# dict.parts = inlines elements in a dictionary entry 
# dict.toplevel = tags for blocks in a dictionary 
# divBot = elements that can occur at the end of a division
#          (byline, closing, epigraph, signed, ...)
# divTop = elements that can occur at the start of a division
#          (similar to divBot)
# dramaFront = elements that occur at the elemenets of divisions in a drama
#              (castlist, epilog, performance, prologue, set)
# edit = inline for editorial corrections (deletions, edits...)
# editIncl = same but can be anywhere (gap)
# fm.chunk = frontmatter when no titlepage
# front, back = level of divisions in front or back matter
#               (divGen, dramaFront)
# hqInter = highlighting (q, quote, cit)
# hqPhrase = highlighting (distinct, emph, foreign, gloss, hi, mentioned, socalled,
#                          term, title)
# Incl = (anchor, etc.)
# lists = listlike elements
# listBibl = biblist
# metadata (metadata Incl: links, certainty, index)
# names = persons. places, things (bloc, country, goegname, personname, region, ...)
# notes = notelike elements (footnote, remark)
# personPart = first, surname, ...
# phrase = inlines
# phrase.verse = verses
# placePart = names of places
# seg = elements used for arbitrary segmentation (clauses, phrase, morphemes, words)
# sgmlKeywords = att, gi
# stageDirection = camera, caption, move, sound, tech, view
# tpParts = title page parts (as in a written work)


namespace ctrl = "http://nwalsh.com/xmlns/schema-control/"
namespace rng  = "http://relaxng.org/ns/structure/1.0"
namespace s = "http://www.ascc.net/xml/schematron"

# ======================================================================

id.attribute        = attribute id { xsd:ID }

xml.lang.attribute  = attribute xml:lang { text }

xml.base.attribute  = attribute xml:base { text }

remap.attribute     = attribute remap { text }

xreflabel.attribute = attribute xreflabel { text }

role.attribute      = attribute role { text }

revisionflag.attribute =
  attribute revisionflag { "changed" | "added" | "deleted" | "off" }

effectivity.attributes =
  arch.attribute?,
  condition.attribute?,
  conformance.attribute?,
  os.attribute?,
  revision.attribute?,
  security.attribute?,
  userlevel.attribute?,
  vendor.attribute?

arch.attribute        = attribute arch        { text }
condition.attribute   = attribute condition   { text }
conformance.attribute = attribute conformance { text }
os.attribute          = attribute os          { text }
revision.attribute    = attribute revision    { text }
security.attribute    = attribute security    { text }
userlevel.attribute   = attribute userlevel   { text }
vendor.attribute      = attribute vendor      { text }

# ======================================================================

linkend.attribute  = attribute linkend { xsd:IDREF }

linkends.attribute = attribute linkends { xsd:IDREFS }

href.attribute = attribute href { text }

# ======================================================================

common.attributes =
  id.attribute?,
  xml.lang.attribute?,
  xml.base.attribute?,
  remap.attribute?,
  xreflabel.attribute?,
  revisionflag.attribute?,
  effectivity.attributes

common.attrib.idreq =
  id.attribute,
  xml.lang.attribute?,
  xml.base.attribute?,
  remap.attribute?,
  xreflabel.attribute?,
  revisionflag.attribute?,
  effectivity.attributes

common.linking.attributes.req =
   linkend.attribute | href.attribute

common.linking.attributes =
   (linkend.attribute | href.attribute)?

# ======================================================================

relation.attribute = attribute relation { text }?

linenumbering.attribute      = attribute linenumbering { "numbered" | "unnumbered" }
startinglinenumber.attribute = attribute startinglinenumber { xsd:integer }
verb-language.attribute      = attribute language { text }
continuation.attribute       = attribute continuation { "continues" | "restarts" }

verbatim.attributes &=
   continuation.attribute?,
   linenumbering.attribute?,
   startinglinenumber.attribute?,
   verb-language.attribute?

float.attribute = attribute float { text }
pgwide.attribute = attribute pgwide { "0" | "1" }

data.format.attribute = attribute format { text }
data.fileref.attribute = attribute fileref { text }
data.entityref.attribute = attribute entityref { xsd:ENTITY }
data.common.attribute &=
   data.format.attribute?,
   (data.fileref.attribute | data.entityref.attribute)

oo-language.attribute = attribute language { text }?

ctrl:other-attribute [ name="biblio.class.attrib"
                       enum-name="biblio.class-enum.attribute"
                       other-name="biblio.class-other.attributes" ]

biblio.class-enum.attribute =
   attribute class {
      "doi"
    | "isbn"
    | "issn"
    | "libraryofcongress"
    | "pubnumber"
    | "uri" }?

biblio.class-other.attributes =
   attribute class { "other" },
   attribute otherclass { xsd:NMTOKEN }

biblio.class.attrib = (biblio.class-enum.attribute | biblio.class-other.attributes)

significance.attribute = attribute significance { "normal" | "preferred" }
zone.attribute = attribute zone { xsd:IDREFS }
pagenum.attribute = attribute pagenum { text }
scope.attribute = attribute scope { "all" | "global" | "local" }

# ======================================================================

ubiq.inlines     = db.inlinemediaobject | db.anchor | db.indexterm | db.remark

text.phrase      = element phrase { docbook.text }

docbook.text     = (text | ubiq.inlines | text.phrase | db.replaceable)*

# ======================================================================

inlines = text | ubiq.inlines | general.inlines | domain.inlines | extension.inlines

general.inlines =
   publishing.inlines
 | product.inlines
 | bibliography.inlines
 | glossary.inlines
 | graphic.inlines
 | indexing.inlines
 | link.inlines

domain.inlines =
   technical.inlines
 | error.inlines
 | os.inlines
 | programming.inlines
 | markup.inlines
 | math.inlines
 | gui.inlines
 | keyboard.inlines

technical.inlines =
  db.replaceable | db.systemitem | db.option | db.optional

error.inlines =
  db.errorcode | db.errortext | db.errorname | db.errortype

oo.inlines = db.ooclass | db.ooexception | db.oointerface

# TEI: code, programlisting (x.data)

programming.inlines =
   db.function
 | db.parameter
 | db.varname
 | db.returnvalue
 | db.type
 | db.classname
 | db.exceptionname
 | db.interfacename
 | db.methodname
 | db.modifier
 | db.initializer
 | oo.inlines

# TEI: names

product.inlines =
   db.productnumber
 | db.productname
 | db.database
 | db.application
 | db.hardware
 | db.trademark

# TEI: x.data

os.inlines =
   db.prompt
 | db.envar
 | db.filename
 | db.command
 | db.computeroutput
 | db.userinput

# TEI: sgmlKeywords, ident

markup.inlines =
   db.xmltag
 | db.markup
 | db.token
 | db.symbol
 | db.literal
 | db.code
 | db.constant

# TEI: no class

bibliography.inlines =
   db.citation
 | db.citerefentry
 | db.citetitle
 | db.citebiblioid
 | db.author
 | db.personname
 | db.orgname
 | db.editor

# TEI: no class

glossary.inlines =
   db.firstterm
 | db.glossterm

# TEI: hqPhrase

publishing.inlines =
   db.abbrev
 | db.acronym
 | db.emphasis
 | db.footnote
 | db.footnoteref
 | db.foreignphrase
 | db.phrase
 | db.quote
 | db.subscript
 | db.superscript
 | db.wordasword

# TEI: formula

math.inlines = db.inlineequation

# TEI: figure

graphic.inlines = db.inlinemediaobject

# TEI: metadata

indexing.inlines = db.indexterm

# TEI: 

gui.inlines =
   db.guiicon
 | db.guibutton
 | db.guimenuitem
 | db.guimenu
 | db.guisubmenu
 | db.guilabel
 | db.menuchoice
 | db.mousebutton

keyboard.inlines =
   db.keycombo
 | db.keycap
 | db.keycode
 | db.keysym
 | db.shortcut
 | db.accel

link.inlines =
   db.xref
 | db.uri
 | db.anchor

extension.inlines = notAllowed

# ======================================================================

blocks.nopara =
   list.blocks
 | admonition.blocks
 | formal.blocks
 | informal.blocks
 | publishing.blocks
 | graphic.blocks
 | technical.blocks
 | verbatim.blocks
 | synopsis.blocks
 | db.indexterm
 | db.bridgehead
 | db.remark
 | db.revhistory

blocks =
   blocks.nopara
 | para.blocks
 | extension.blocks

formal.blocks =
   db.equation
 | db.example
 | db.figure
 | db.table

informal.blocks =
   db.informalequation
 | db.informalexample
 | db.informalfigure
 | db.informaltable

publishing.blocks =
   db.sidebar
 | db.blockquote
 | db.address
 | db.epigraph

graphic.blocks = db.mediaobject | db.screenshot

technical.blocks = db.procedure

admonition.blocks =
   db.caution
 | db.important
 | db.note
 | db.tip
 | db.warning

list.blocks =
   db.itemizedlist
 | db.orderedlist
 | db.procedure
 | db.simplelist
 | db.variablelist
 | db.qandaset
 | db.glosslist
 | db.segmentedlist

verbatim.blocks =
   db.programlisting
 | db.screen
 | db.literallayout
 | db.synopsis

synopsis.blocks =
   db.cmdsynopsis
 | db.funcsynopsis
 | db.classsynopsis
 | db.methodsynopsis
 | db.constructorsynopsis
 | db.destructorsynopsis
 | db.fieldsynopsis

extension.blocks = notAllowed

# ======================================================================

db.title = element title { inlines* }

db.titleabbrev = element titleabbrev { inlines* }

db.subtitle = element subtitle { inlines* }

docbook.title = db.title? & db.titleabbrev? & db.subtitle?
docbook.titlereq = db.title & db.titleabbrev? & db.subtitle?
docbook.titleonly = db.title? & db.titleabbrev?
docbook.titleonlyreq = db.title & db.titleabbrev?

info.elements =
   db.biblioid
 | db.artpagenums
 | db.copyright
 | db.subjectset
 | db.keywordset
 | db.subjectset
 | db.keywordset
 | db.itermset
 | db.abstract
 | db.authorgroup
 | db.author
 | db.editor
 | db.othercredit
 | db.bibliocoverage
 | db.bibliomisc
 | db.bibliomset
 | db.bibliorelation
 | db.biblioset
 | db.collab
 | db.confgroup
 | db.date
 | db.pubdate
 | db.edition
 | db.volumenum
 | db.issuenum
 | db.seriesvolnums
 | db.pagenums
 | db.legalnotice
 | db.publisher
 | db.releaseinfo
 | db.revhistory
 | db.printhistory

bibliographic.elements =
   info.elements
 | db.abbrev
 | db.title
 | db.titleabbrev
 | db.subtitle
 | db.citetitle
 | db.address
 | db.affiliation
 | db.personblurb
 | db.authorinitials
 | db.personname
 | db.orgname
 | db.productname
 | db.productnumber
 | db.publishername

db.biblioentry = element biblioentry { bibliographic.elements+ }

db.bibliomixed = element bibliomixed { (text | bibliographic.elements)* }

db.info = element info { docbook.title, info.elements* }
db.info.titlereq = element info { docbook.titlereq, info.elements* }
db.info.titleonly = element info { docbook.titleonly, info.elements* }
db.info.titleonlyreq = element info { docbook.titleonlyreq, info.elements* }
db.info.titleforbidden = element info { info.elements* }

docbook.info = (docbook.titlereq?, db.info.titleforbidden?) | db.info?
docbook.info.titlereq = (docbook.titlereq, db.info.titleforbidden?) | db.info.titlereq
docbook.info.titleonly = (docbook.titleonly, db.info.titleforbidden?) | db.info.titleonly
docbook.info.titleonlyreq = (docbook.titleonlyreq, db.info.titleforbidden?) | db.info.titleonlyreq
docbook.info.titleforbidden = db.info.titleforbidden?

ctrl:alternate-define [
   name="docbook.title"
   rng:optional [
      rng:ref [ name = "db.title" ]
   ]
   rng:optional [
      rng:ref [ name = "db.titleabbrev" ]
   ]
   rng:optional [
      rng:ref [ name = "db.subtitle" ]
   ]
]

ctrl:alternate-define [
   name="docbook.titlereq"
   rng:ref [ name="db.title" ]
   rng:optional [
      rng:ref [ name = "db.titleabbrev" ]
   ]
   rng:optional [
      rng:ref [ name = "db.subtitle" ]
   ]
]

ctrl:alternate-define [
   name="db.info"
   rng:element [
      name="info"
      rng:zeroOrMore [
         rng:choice [
            rng:ref [ name = "docbook.title" ]
            rng:ref [ name = "info.elements" ]
         ]
      ]
   ]
]

ctrl:alternate-define [
   name = "docbook.info"
   rng:optional [
      rng:ref [ name = "db.info" ]
   ]
]

ctrl:alternate-define [
   name = "docbook.info.titlereq"
   rng:ref [ name = "docbook.titlereq" ]
   rng:optional [
      rng:ref [ name = "db.info" ]
   ]
]

ctrl:alternate-define [
   name = "docbook.info.titleforbidden"
   rng:optional [
      rng:ref [ name = "db.info" ]
   ]
]

biblioset.relation.attrib = relation.attribute
db.biblioset = element biblioset { bibliographic.elements+ }

bibliomset.relation.attrib = relation.attribute
db.bibliomset = element bibliomset { (docbook.text | bibliographic.elements)* }

db.bibliomisc = element bibliomisc { docbook.text }

subjectset.scheme.attrib = attribute scheme { xsd:NMTOKEN }?
db.subjectset = element subjectset { db.subject+ }

subject.weight.attrib = attribute weight { text }?
db.subject = element subject { db.subjectterm+ }

db.subjectterm = element subjectterm { text }

db.keywordset = element keywordset { db.keyword+ }

db.keyword = element keyword { text }

db.itermset = element itermset { indexterm.singular+ }

qandaset.defaultlabel.attrib = attribute defaultlabel { "none" | "number" | "qanda" }?
qandaset.info = docbook.info.titleonly
db.qandaset =
   element qandaset { qandaset.info, blocks*, (db.qandadiv+ | db.qandaentry+) }

qandadiv.info = docbook.info.titleonly
db.qandadiv =
   element qandadiv { qandadiv.info, blocks*, (db.qandadiv+ | db.qandaentry+) }

qandaentry.info = docbook.info.titleforbidden
db.qandaentry =
   element qandaentry { qandaentry.info, db.question, db.answer* }

db.question = element question { db.label?, blocks+ }

db.answer = element answer { db.label?, blocks+ }

db.label = element label { docbook.text }

table.choice = notAllowed
informaltable.choice = notAllowed

db.table = table.choice
db.informaltable = informaltable.choice

procedure.info = docbook.info.titleonly
db.procedure = element procedure { procedure.info, blocks*, db.step+ }

step.performance.attrib = attribute performance { "optional" | "required" }?
step.info = docbook.info.titleonly
db.step = element step {
   step.info,
   blocks*,
   (db.substeps|db.stepalternatives)?,
   blocks* }

stepalternatives.performance.attrib = attribute performance { "optional" | "required" }?
stepalternatives.info = docbook.info.titleforbidden
db.stepalternatives = element stepalternatives { stepalternatives.info, db.step+ }

substeps.performance.attrib = attribute performance { "optional" | "required" }?
db.substeps = element substeps { db.step+ }

ctrl:exclude [ from="db.sidebar" exclude="db.sidebar" ]

sidebar.info = docbook.info.titleonly

db.sidebar = element sidebar { sidebar.info, blocks+ }

abstract.info = docbook.info.titleonly
db.abstract = element abstract { abstract.info, para.blocks+ }

personblurb.info = docbook.info.titleonly
db.personblurb = element personblurb { personblurb.info, para.blocks+ }

blockquote.info = docbook.info.titleonly
db.blockquote = element blockquote { blockquote.info, db.attribution?, blocks+ }

db.attribution = element attribution { (docbook.text | db.personname) }

bridgehead.renderas.attrib =
   attribute renderas {
      "other"
    | "sect1"
    | "sect2"
    | "sect3"
    | "sect4"
    | "sect5" }?

db.bridgehead = element bridgehead { inlines* }

db.remark = element remark { docbook.text }

epigraph.info = docbook.info.titleforbidden

db.epigraph =
   element epigraph {
      epigraph.info,
      db.attribution?,
      (para.blocks | db.literallayout)+
   }

ctrl:exclude [ from="db.footnote" exclude="db.footnote" ]

db.footnote = element footnote { blocks+ }

db.highlights = element highlights {
   (list.blocks | admonition.blocks | para.blocks | db.indexterm)+
}

para.blocks =
   db.anchor
 | db.para
 | db.formalpara
 | db.simpara

formalpara.info = docbook.info.titleonlyreq
db.formalpara = element formalpara { formalpara.info, db.indexterm*, db.para }

para.info = docbook.info.titleforbidden
db.para = element para { para.info, (inlines | blocks.nopara)* }

simpara.info = docbook.info.titleforbidden
db.simpara = element simpara { simpara.info, inlines* }

# admonitions are not excluded from themselves
admonition.contentmodel = docbook.info.titleonly, blocks+

db.caution = element caution { admonition.contentmodel }

ctrl:exclude [ from="admonition.blocks" exclude="admonition.blocks" ]

db.important = element important { admonition.contentmodel }

db.note = element note { admonition.contentmodel }

db.tip = element tip { admonition.contentmodel }

db.warning = element warning { admonition.contentmodel }

glosslist.info = docbook.info.titleonly
db.glosslist = element glosslist { glosslist.info?, blocks*, db.glossentry+ }

glossentry.sortas.attrib = sortas.attribute?
db.glossentry =
   element glossentry {
      db.glossterm,
      db.acronym?,
      db.abbrev?,
      db.indexterm*,
      (db.glosssee | db.glossdef+)
   }

glossdef.subject.attrib = attribute subject { text }?
db.glossdef = element glossdef { blocks+, db.glossseealso* }

glosssee.otherterm.attrib = attribute otherterm { xsd:IDREF }?
db.glosssee =
   [
      s:rule [
         context = "glosssee[@linkend]"
         s:assert [
            test = "name(//*[@id=current()/@linkend]) = 'glossentry'"
            "@linkend on glosssee must point to a glossentry."
         ]
      ]
   ]
   element glosssee { inlines* }

glossseealso.otherterm.attrib = attribute otherterm { xsd:IDREF }?
db.glossseealso =
   [
      s:rule [
         context = "glossseealso[@linkend]"
         s:assert [
            test = "name(//*[@id=current()/@linkend]) = 'glossentry'"
            "@linkend on glossseealso must point to a glossentry."
         ]
      ]
   ]
   element glossseealso { inlines* }

itemizedlist.mark.attrib = attribute mark { text }?
itemizedlist.spacing.attrib = attribute spacing { "compact" | "normal" }?

itemizedlist.info = docbook.info.titleonly
db.itemizedlist = element itemizedlist { itemizedlist.info, blocks*, db.listitem+ }

orderedlist.inheritnum.attrib = attribute inheritnum { "ignore" | "inherit" }?
orderedlist.spacing.attrib = attribute spacing { "compact" | "normal" }?
orderedlist.continuation.attrib = continuation.attribute?
orderedlist.numeration.attrib = attribute numeration { text }?

orderedlist.info = docbook.info.titleonly
db.orderedlist = element orderedlist { orderedlist.info, blocks*, db.listitem+ }

listitem.override.attrib = attribute override { text }?
db.listitem = element listitem { blocks+ }

segmentedlist.info = docbook.info.titleonly
db.segmentedlist =
   element segmentedlist {
      segmentedlist.info,
      db.segtitle+,
      db.seglistitem+ }

db.segtitle = element segtitle { inlines* }

db.seglistitem =
   [
      s:rule [
         context = "seglistitem"
         s:assert [
            test = "count(seg) = count(../segtitle)"
            "The number of seg elements must be the same as the number of segtitle elements in the parent segmentedlist"
         ]
      ]
   ]
   element seglistitem { db.seg+ }

db.seg = element seg { inlines* }

simplelist.type.attrib = attribute type { "horiz" | "vert" | "inline" }?
simplelist.columns.attrib = attribute columns { xsd:integer}?
db.simplelist = element simplelist { db.member+ }

db.member = element member { inlines* }

variablelist.termlength.attrib = attribute termlength { text }?
variablelist.info = docbook.info.titleonly

db.variablelist = element variablelist { variablelist.info, blocks*, db.varlistentry+ }

db.varlistentry = element varlistentry { db.term+, db.listitem }

db.term = element term { inlines* }

floatstyle.attribute = attribute floatstyle { text }

example.floatstyle.attrib = floatstyle.attribute?
example.width.attrib = attribute width { text }?
example.label.attrib = attribute label { text }?

example.info = docbook.info.titleonlyreq
db.example = element example { example.info, blocks+ }

informalexample.info = docbook.info.titleforbidden
informalexample.width.attrib = attribute width { text }?
informalexample.floatstyle.attrib = floatstyle.attribute?
db.informalexample = element informalexample { informalexample.info, blocks+ }

verbatim.inlines = inlines | db.lineannotation

verbatim.contentmodel = docbook.info.titleforbidden, (db.textobject|verbatim.inlines*)

programlisting.verbatim.attribs = verbatim.attributes
programlisting.width.attrib = attribute width { text }?
db.programlisting = element programlisting { verbatim.contentmodel }

literallayout.verbatim.attribs = verbatim.attributes
literallayout.class.attrib = attribute class { "monospaced" | "normal" }?
db.literallayout = element literallayout { verbatim.contentmodel }

screen.verbatim.attribs = verbatim.attributes
screen.width.attrib = attribute width { text }?
db.screen = element screen { verbatim.contentmodel }

screenshot.block = db.mediaobject

screenshot.info = docbook.info
db.screenshot =
   element screenshot { screenshot.info, screenshot.block }

figure.floatstyle.attrib = floatstyle.attribute?
figure.float.attrib = attribute float { text }?
figure.pgwide.attrib = pgwide.attribute?
figure.label.attrib = attribute label { text }?
figure.info = docbook.info.titleonlyreq
db.figure = element figure { figure.info, blocks+ }

informalfigure.floatstyle.attrib = floatstyle.attribute?
informalfigure.float.attrib = float.attribute?
informalfigure.pgwide.attrib = pgwide.attribute?
informalfigure.label.attrib = attribute label { text }?
informalfigure.info = docbook.info.titleforbidden
db.informalfigure = element informalfigure { informalfigure.info, blocks+ }

mediaobject.content =
   db.videoobject | db.audioobject | db.imageobject | db.textobject

mediaobject.info = docbook.info.titleforbidden
db.mediaobject =
   element mediaobject { mediaobject.info, mediaobject.content+ }

inlinemediaobject.content =
   db.videoobject | db.audioobject | db.imageobject | db.textobject

inlinemediaobject.info = docbook.info.titleforbidden
db.inlinemediaobject =
   element inlinemediaobject { inlinemediaobject.info, inlinemediaobject.content+ }

videoobject.info = docbook.info.titleforbidden
db.videoobject = element videoobject { videoobject.info, db.videodata }

audioobject.info = docbook.info.titleforbidden
db.audioobject = element audioobject { audioobject.info, db.audiodata }

imageobject.content = db.imagedata

imageobject.info = docbook.info.titleforbidden
db.imageobject = element imageobject { imageobject.info, imageobject.content }

textobject.info = docbook.info.titleforbidden
db.textobject =
   element textobject { textobject.info, (db.phrase | db.textdata | blocks+) }

videodata.data.attrib = data.common.attribute
videodata.align.attrib =
  attribute align { "center" | "char" | "justify" | "left" | "right" }?
videodata.valign.attrib = attribute valign { "bottom" | "middle" | "top" }?
videodata.width.attrib = attribute width { text }?
videodata.contentwidth.attrib = attribute contentwidth { text }?
videodata.scalefit.attrib = attribute scalefit { "0" | "1" }?
vidoedata.scale.attrib = attribute scale { text }?
videodata.depth.attrib = attribute depth { text }?
videodata.contentdepth.attrib = attribute contentdepth { text }?

videodata.info = docbook.info.titleforbidden
db.videodata = element videodata { videodata.info }

audiodata.data.attrib = data.common.attribute
audiodata.info = docbook.info.titleforbidden
db.audiodata = element audiodata { audiodata.info }

imagedata.data.attrib = data.common.attribute
imagedata.align.attrib =
  attribute align { "center" | "char" | "justify" | "left" | "right" }?
imagedata.valign.attrib = attribute valign { "bottom" | "middle" | "top" }?
imagedata.width.attrib = attribute width { text }?
imagedata.contentwidth.attrib = attribute contentwidth { text }?
imagedata.scalefit.attrib = attribute scalefit { "0" | "1" }?
imagedata.scale.attrib = attribute scale { text }?
imagedata.depth.attrib = attribute depth { text }?
imagedata.contentdepth.attrib = attribute contentdepth { text }?

imagedata.info = docbook.info.titleforbidden
db.imagedata = element imagedata { imagedata.info }

textdata.data.attrib = data.common.attribute
textdata.encoding.attrib = attribute encoding { text }?

textdata.info = docbook.info.titleforbidden
db.textdata = element textdata { textdata.info }

db.caption = element caption { blocks+ }

equation.content = db.mediaobject

equation.info = docbook.info.titleonlyreq
db.equation = element equation { equation.info, equation.content+ }

informalequation.info = docbook.info.titleforbidden
db.informalequation =
   element informalequation {
      informalequation.info,
      equation.content+
   }

inlineequation.content = db.inlinemediaobject

db.inlineequation = element inlineequation { inlineequation.content+ }

synopsis.verbatim.attribs = verbatim.attributes
synopsis.label.attrib = attribute label { text }
db.synopsis = element synopsis { verbatim.contentmodel }

cmdsynopsis.sepchar.attrib = attribute sepchar { text }?
cmdsynopsis.cmdlength.attrib = attribute cmdlength { text }?
cmdsynopsis.label.attrib = attribute label { text }?

cmdsynopsis.info = docbook.info.titleforbidden
db.cmdsynopsis =
   element cmdsynopsis {
      cmdsynopsis.info?,
      (db.command | db.arg | db.group | db.sbr)+,
      db.synopfragment*
   }

rep.attribute = attribute rep { "norepeat" | "repeat" }
choice.attribute = attribute choice { "opt" | "plain" | "req" }

arg.rep.attrib = rep.attribute?
arg.choice.attrib = choice.attribute?

db.arg =
   element arg {
      (docbook.text
       | db.arg
       | db.group
       | db.option
       | db.synopfragmentref
       | db.sbr)*
   }


group.rep.attrib = rep.attribute?
group.choice.attrib = choice.attribute?

db.group =
   element group {
      (db.arg | db.group | db.option | db.synopfragmentref | db.replaceable | db.sbr)+
   }

ctrl:common-linking [ element="sbr" suppress="yes" ]

db.sbr = element sbr { empty }

db.synopfragment = element synopfragment { (db.arg | db.group)+ }

synopfragmentref.linkend.attrib = linkend.attribute
db.synopfragmentref =
   [
      s:rule [
         context = "synopfragmentref"
         s:assert [
            test = "name(//*[@id=current()/@linkend]) = 'synopfragment'"
            "@linkend on synopfragmentref must point to a synopfragment."
         ]
      ]
   ]
   element synopfragmentref { text }

funcsynopsis.info = docbook.info.titleforbidden
db.funcsynopsis =
   element funcsynopsis {
      funcsynopsis.info?,
      (db.funcsynopsisinfo | db.funcprototype)+
   }

funcsynopsisinfo.verbatim.attribs = verbatim.attributes
db.funcsynopsisinfo = element funcsynopsisinfo { verbatim.contentmodel }

db.funcprototype =
   element funcprototype {
      db.modifier*,
      db.funcdef,
      (db.void | db.varargs | (db.paramdef+, db.varargs?)),
      db.modifier*
   }

db.funcdef = element funcdef { (docbook.text | db.type | db.function)* }

db.void = element void { empty }

db.varargs = element varargs { empty }

paramdef.choice.attrib = attribute choice { "opt" | "req" }?

db.paramdef =
   element paramdef { (docbook.text | db.type | db.parameter | db.funcparams)* }

db.funcparams = element funcparams { inlines* }

oo-method.synopsis.blocks =
  db.methodsynopsis | db.constructorsynopsis | db.destructorsynopsis

oo-field.synopsis.blocks = db.fieldsynopsis

classsynopsis.language.attrib = oo-language.attribute
classsynopsis.class.attrib = attribute class { "class" | "interface" }?
db.classsynopsis =
   element classsynopsis {
      oo.inlines+,
      (db.classsynopsisinfo
       | oo-method.synopsis.blocks
       | oo-field.synopsis.blocks)*
   }

classsynopsisinfo.verbatim.attribs = verbatim.attributes
db.classsynopsisinfo = element classsynopsisinfo { verbatim.contentmodel }

db.ooclass = element ooclass { db.modifier*, db.classname }

db.oointerface = element oointerface { db.modifier*, db.interfacename }

db.ooexception = element ooexception {db.modifier*, db.exceptionname  }

db.modifier = element modifier { docbook.text }

db.interfacename = element interfacename { docbook.text }

db.exceptionname = element exceptionname { docbook.text }

fieldsynopsis.language.attrib = oo-language.attribute
db.fieldsynopsis =
   element fieldsynopsis {
      db.modifier*,
      db.type?,
      db.varname,
      db.initializer?
   }

db.initializer = element initializer { docbook.text }

constructorsynopsis.language.attrib = oo-language.attribute
db.constructorsynopsis =
   element constructorsynopsis {
      db.modifier*,
      db.methodname?,
      (db.methodparam+ | db.void?),
      db.exceptionname*
   }

destructorsynopsis.language.attrib = oo-language.attribute
db.destructorsynopsis =
   element destructorsynopsis {
      db.modifier*,
      db.methodname?,
      (db.methodparam+ | db.void?),
      db.exceptionname*
   }

methodsynopsis.language.attrib = oo-language.attribute
db.methodsynopsis =
   element methodsynopsis {
      db.modifier*,
      (db.type | db.void)?,
      db.methodname,
      (db.methodparam+ | db.void),
      db.exceptionname*,
      db.modifier*
   }

db.methodname = element methodname { docbook.text }

methodparam.rep.attrib = rep.attribute?
methodparam.choice.attrib = choice.attribute?

db.methodparam =
   element methodparam {
      db.modifier*,
      db.type?,
      ((db.parameter, db.initializer?) | db.funcparams),
      db.modifier*
   }

# TEI: addrPart

address.verbatim.attribs = verbatim.attributes
db.address =
   element address {
      (docbook.text
       | db.personname
       | db.pob
       | db.street
       | db.city
       | db.state
       | db.postcode
       | db.country
       | db.phone
       | db.fax
       | db.email
       | db.otheraddr)*
   }

db.street = element street { docbook.text }
db.pob = element pob { docbook.text }
db.postcode = element postcode { docbook.text }
db.city = element city { docbook.text }
db.state = element state { docbook.text }
db.country = element country { docbook.text }
db.phone = element phone { docbook.text }
db.fax = element fax { docbook.text }
db.otheraddr = element otheraddr { docbook.text }

db.affiliation =
   element affiliation {
      db.shortaffil?,
      db.jobtitle*,
      db.orgname?,
      db.orgdiv*,
      db.address*
   }

db.shortaffil = element shortaffil { docbook.text }

db.jobtitle = element jobtitle { docbook.text }

ctrl:other-attribute [ name="orgname.class.attrib"
                       enum-name="orgname.class-enum.attribute"
                       other-name="orgname.class-other.attributes" ]

orgname.class-enum.attribute =
   attribute class {
      "consortium"
    | "corporation"
    | "informal"
    | "nonprofit" }?

orgname.class-other.attributes =
   attribute class { "other" },
   attribute otherclass { text }

orgname.class.attrib = (orgname.class-enum.attribute | orgname.class-other.attributes)

db.orgname = element orgname { docbook.text }

db.orgdiv = element orgdiv { inlines* }

db.artpagenums = element artpagenums { docbook.text }

db.personname =
   element personname {
      docbook.text
    | (db.honorific
     | db.firstname
     | db.surname
     | db.lineage
     | db.othername)+
   }

person.author =
   db.personname,
   (db.personblurb
    | db.affiliation
    | db.email
    | db.address
    | db.contrib)*

org.author =
   db.orgname,
   (db.orgdiv
    | db.affiliation
    | db.email
    | db.address
    | db.contrib)*

credit.contentmodel = person.author | org.author

db.author = element author { credit.contentmodel }

db.authorgroup = element authorgroup { (db.author | db.editor | db.othercredit)+ }

db.collab = element collab { (db.personname | db.orgname)+, db.affiliation* }

db.authorinitials = element authorinitials { docbook.text }

db.confgroup =
   element confgroup {
      (db.confdates
       | db.conftitle
       | db.confnum
       | db.confsponsor
       | db.address)*
   }

db.confdates = element confdates { docbook.text }

db.conftitle = element conftitle { docbook.text }

db.confnum = element confnum { docbook.text }

db.confsponsor = element confsponsor { docbook.text }

db.contractnum = element contractnum { docbook.text }

db.contractsponsor = element contractsponsor { docbook.text }

db.copyright = element copyright { db.year+, db.holder* }

db.year = element year { docbook.text }

db.holder = element holder { docbook.text }

db.date = element date { docbook.text }

db.edition = element edition { docbook.text }

db.editor = element editor { credit.contentmodel }

biblioid.class.attrib = biblio.class.attrib
db.biblioid = element biblioid { docbook.text }

citebiblioid.class.attrib = biblio.class.attrib
db.citebiblioid =
   element citebiblioid { docbook.text }

bibliosource.class.attrib = biblio.class.attrib
db.bibliosource = element bibliosource { docbook.text }

bibliorelation.class.attrib = biblio.class.attrib

ctrl:other-attribute [ name="bibliorelation.type.attrib"
                       enum-name="bibliorelation.type-enum.attribute"
                       other-name="bibliorelation.type-other.attributes" ]

bibliorelation.type-enum.attribute =
   attribute type { "hasformat"
    | "haspart"
    | "hasversion"
    | "isformatof"
    | "ispartof"
    | "isreferencedby"
    | "isreplacedby"
    | "isrequiredby"
    | "isversionof"
    | "othertype"
    | "references"
    | "replaces"
    | "requires" }?

bibliorelation.type-other.attributes =
   attribute type { "othertype" },
   attribute othertype { xsd:NMTOKEN }

bibliorelation.type.attrib =
   (bibliorelation.type-enum.attribute | bibliorelation.type-other.attributes)

db.bibliorelation = element bibliorelation { docbook.text }

ctrl:other-attribute [ name="bibliocoverage.spatial.attrib"
                       enum-name="bibliocoverage.spatial-enum.attribute"
                       other-name="bibliocoverage.spatial-other.attributes" ]

bibliocoverage.spatial-enum.attribute =
   attribute spatial {
      "dcmipoint" | "iso3166" | "dcmibox" | "tgn"
   }

bibliocoverage.spatial-other.attributes =
   attribute spatial { "otherspatial" },
   attribute otherspatial { xsd:NMTOKEN }

bibliocoverage.spatial.attrs =
   (bibliocoverage.spatial-enum.attribute | bibliocoverage.spatial-other.attributes)

ctrl:other-attribute [ name="bibliocoverage.temporal.attrib"
                       enum-name="bibliocoverage.temporal-enum.attribute"
                       other-name="bibliocoverage.temporal-other.attributes" ]

bibliocoverage.temporal-enum.attribute =
   attribute temporal {
      "dcmiperiod" | "w3c-dtf"
   }

bibliocoverage.temporal-other.attributes =
   attribute temporal { "othertemporal" },
   attribute othertemporal { xsd:NMTOKEN }

bibliocoverage.temporal.attrs =
   (bibliocoverage.temporal-enum.attribute | bibliocoverage.temporal-other.attributes)

bibliocoverage.coverage.attrib =
   (bibliocoverage.spatial.attrs | bibliocoverage.temporal.attrs)
 | (bibliocoverage.spatial.attrs & bibliocoverage.temporal.attrs)

db.bibliocoverage = element bibliocoverage { docbook.text }

legalnotice.info = docbook.info.titleonly
db.legalnotice = element legalnotice { legalnotice.info, blocks+ }

othercredit.class.attrib = attribute class {
   "copyeditor"
 | "graphicdesigner"
 | "other"
 | "productioneditor"
 | "technicaleditor"
 | "translator" }?

db.othercredit = element othercredit { credit.contentmodel }

db.pagenums = element pagenums { docbook.text }

db.contrib = element contrib { docbook.text }

db.honorific = element honorific { docbook.text }

db.firstname = element firstname { docbook.text }

db.surname = element surname { docbook.text }

db.lineage = element lineage { docbook.text }

db.othername = element othername { docbook.text }

db.printhistory = element printhistory { para.blocks+ }

productname.class.attrib = attribute class {
   "copyright" | "registered" | "service" | "trade" }?
db.productname = element productname { docbook.text }

db.productnumber = element productnumber { docbook.text }

db.pubdate = element pubdate { docbook.text }

db.publisher = element publisher { db.publishername, db.address* }

db.publishername = element publishername { docbook.text }

db.releaseinfo = element releaseinfo { docbook.text }

revhistory.info = docbook.info.titleonly
db.revhistory = element revhistory { revhistory.info, db.revision+ }

db.revision =
   element revision {
      db.revnumber,
      db.date,
      (db.authorinitials | db.author)*,
      (db.revremark | db.revdescription)?
   }

db.revnumber = element revnumber { docbook.text }

db.revremark = element revremark { docbook.text }

db.revdescription = element revdescription { blocks* }

db.seriesvolnums = element seriesvolnums { docbook.text }

db.volumenum = element volumenum { docbook.text }

db.issuenum = element issuenum { docbook.text }

db.accel  = element accel { docbook.text }

application.class.attrib = attribute class { "hardware" | "software" }?
db.application = element application { docbook.text }

db.classname = element classname { docbook.text }

db.command = element command { inlines* }

computeroutput.inlines = (inlines|db.co)

db.computeroutput = element computeroutput { computeroutput.inlines* }

database.class.attrib =
   attribute class {
      "altkey"
    | "constraint"
    | "datatype"
    | "field"
    | "foreignkey"
    | "group"
    | "index"
    | "key1"
    | "key2"
    | "name"
    | "primarykey"
    | "procedure"
    | "record"
    | "rule"
    | "secondarykey"
    | "table"
    | "user"
    | "view"
   }?
db.database = element database { docbook.text }

db.email = element email { docbook.text }

db.envar = element envar { docbook.text }

db.errorcode = element errorcode { docbook.text }

db.errorname = element errorname { docbook.text }

db.errortext = element errortext { docbook.text }

db.errortype = element errortype { docbook.text }

filename.path.attrib = attribute path { text }?
filename.class.attrib =
   attribute class {
      "devicefile"
    | "directory"
    | "extension"
    | "headerfile"
    | "libraryfile"
    | "partition"
    | "symlink"
   }?
db.filename = element filename { docbook.text }

db.function = element function { docbook.text }

db.guibutton = element guibutton { (docbook.text | db.accel)* }

db.guiicon = element guiicon { (docbook.text | db.accel)* }

db.guilabel = element guilabel { (docbook.text | db.accel)* }

db.guimenu = element guimenu { (docbook.text | db.accel)* }

db.guimenuitem =  element guimenuitem { (docbook.text | db.accel)* }

db.guisubmenu = element guisubmenu { (docbook.text | db.accel)* }

db.hardware = element hardware { docbook.text }

ctrl:other-attribute [ name="keycap.function.attrib"
                       enum-name="keycap.function-enum.attribute"
                       other-name="keycap.function-other.attributes" ]

keycap.function-enum.attribute =
   attribute function {
      "alt"
    | "backspace"
    | "command"
    | "control"
    | "delete"
    | "down"
    | "end"
    | "enter"
    | "escape"
    | "home"
    | "insert"
    | "left"
    | "meta"
    | "option"
    | "pagedown"
    | "pageup"
    | "right"
    | "shift"
    | "space"
    | "tab"
    | "up" }?

keycap.function-other.attributes =
   attribute function { "other" },
   attribute otherfunction { text }

keycap.function.attrib =
   (keycap.function-enum.attribute | keycap.function-other.attributes)

db.keycap = element keycap { docbook.text }

db.keycode = element keycode { docbook.text }

ctrl:other-attribute [ name="keycombo.action.attrib"
                       enum-name="keycombo.action-enum.attribute"
                       other-name="keycombo.action-other.attributes" ]

keycombo.action-enum.attribute =
  attribute action {
    "click" | "double-click" | "press" | "seq" | "simul"
  }?

keycombo.action-other.attributes =
   attribute action { "other" },
   attribute otheraction { text }

keycombo.action.attrib =
   (keycombo.action-enum.attribute | keycombo.action-other.attributes)

db.keycombo = element keycombo { (db.keycap|db.keycombo|db.keysym|db.mousebutton)+ }

db.keysym = element keysym { docbook.text }

db.lineannotation = element lineannotation { inlines* }

db.literal = element literal { inlines* }

code.language.attrib = attribute language { text }?
db.code = element code { inlines* }

constant.class.attrib = attribute class { "limit" }?
db.constant = element constant { docbook.text }

db.varname = element varname { docbook.text }

db.markup = element markup { docbook.text }

db.menuchoice = element menuchoice {
   db.shortcut?,
   (db.guibutton|db.guiicon|db.guilabel|db.guimenu|db.guimenuitem|db.guisubmenu)+ }

shortcut.action.attrib = keycombo.action.attrib

db.shortcut = element shortcut {  (db.keycap|db.keycombo|db.keysym|db.mousebutton)+ }

db.mousebutton = element mousebutton { docbook.text }

db.option = element option { docbook.text }

db.optional = element optional { inlines* }

parameter.class.attrib = attribute class { "command" | "function" | "option" }?
db.parameter = element parameter { docbook.text }

prompt.inlines = (docbook.text|db.co)

db.prompt = element prompt { prompt.inlines* }

replaceable.class.attrib =
   attribute class { "command" | "function" | "option" | "parameter" }?
db.replaceable = element replaceable { (docbook.text|db.co)* }

db.returnvalue = element returnvalue { docbook.text }

xmltag.class.attrib =
  attribute class {
    "attribute"
    | "attvalue"
    | "element"
    | "emptytag"
    | "endtag"
    | "genentity"
    | "numcharref"
    | "paramentity"
    | "pi"
    | "sgmlcomment"
    | "starttag"
    | "xmlpi"
  }?
db.xmltag = element xmltag { docbook.text }

symbol.class.attrib = attribute class { "limit" }?
db.symbol = element symbol { docbook.text }

systemitem.class.attrib =
   attribute class {
      "daemon"
    | "domainname"
    | "etheraddress"
    | "event"
    | "eventhandler"
    | "filesystem"
    | "fqdomainname"
    | "groupname"
    | "ipaddress"
    | "library"
    | "macro"
    | "netmask"
    | "newsgroup"
    | "osname"
    | "process"
    | "resource"
    | "server"
    | "service"
    | "systemname"
    | "username"
   }?

systemitem.inlines = (docbook.text|db.co)

db.systemitem = element systemitem { systemitem.inlines* }

uri.type.attrib = attribute type { text }?
db.uri = element uri { docbook.text }

db.token = element token { docbook.text }

db.type = element type { docbook.text }

db.userinput = element userinput { (inlines|db.co)* }

db.abbrev = element abbrev {
   (docbook.text
    | db.superscript
    | db.subscript
    | db.trademark)* }

db.acronym = element acronym {
   (docbook.text
    | db.superscript
    | db.subscript
    | db.trademark)* }

db.citation = element citation { docbook.text }

db.citerefentry = element citerefentry { db.refentrytitle, db.manvolnum? }

db.refentrytitle = element refentrytitle { inlines* }

db.manvolnum = element manvolnum { docbook.text }

citetitle.pubwork.attrib =
   attribute pubwork {
      "article"
    | "bbs"
    | "book"
    | "cdrom"
    | "chapter"
    | "dvd"
    | "emailmessage"
    | "gopher"
    | "journal"
    | "manuscript"
    | "newsposting"
    | "part"
    | "refentry"
    | "section"
    | "series"
    | "set"
    | "webpage"
    | "wiki"
   }?

db.citetitle = element citetitle { inlines* }

db.emphasis = element emphasis { inlines* }

firstterm.baseform.attrib = glossterm.baseform.attrib
db.firstterm =
   [
      s:rule [
         context = "firstterm[@linkend]"
         s:assert [
            test = "name(//*[@id=current()/@linkend]) = 'glossentry'"
            "@linkend on firstterm must point to a glossentry."
         ]
      ]
   ]
   element firstterm { inlines* }

db.foreignphrase = element foreignphrase { inlines* }

glossterm.baseform.attrib = attribute baseform { text }?

db.glossterm =
   [
      s:rule [
         context = "glossterm[@linkend]"
         s:assert [
            test = "name(//*[@id=current()/@linkend]) = 'glossentry'"
            "@linkend on glossterm must point to a glossentry."
         ]
      ]
   ]
   element glossterm { inlines* }

db.phrase = element phrase { inlines* }

db.quote = element quote { inlines* }

db.subscript = element subscript { docbook.text }

db.superscript = element superscript { docbook.text }

trademark.class.attrib =
   attribute class { "copyright" | "registered" | "service" | "trade" }?

db.trademark = element trademark { docbook.text }

db.wordasword = element wordasword { docbook.text }

ctrl:common-linking [ element="footnoteref" suppress="yes" ]

footnoteref.linkend.attrib = linkend.attribute
footnoteref.label.attrib = attribute label { text }?
db.footnoteref =
   [
      s:rule [
         context = "footnoteref"
         s:assert [
            test = "name(//*[@id=current()/@linkend]) = 'footnote'"
            "@linkend on footnoteref must point to a footnote."
         ]
      ]
   ]
   element footnoteref { empty }

ctrl:common-linking [ element="xref" attributes="common.linking.attributes.req" ]

xref.xrefstyle.attrib = attribute xrefstyle { text }?
xref.endterm.attrib = attribute endterm { xsd:IDREF }?
db.xref = element xref { empty }

ctrl:common-linking [ element="anchor" suppress="yes" ]
ctrl:common-attributes [ element="anchor" attributes="common.attrib.idreq" ]

db.anchor = element anchor { empty }

indexterm.singular.significance.attrib = significance.attribute?
indexterm.startofrange.significance.attrib = significance.attribute?
indexterm.endofrange.significance.attrib = significance.attribute?

indexterm.singular.zone.attrib = zone.attribute?
indexterm.startofrange.zone.attrib = zone.attribute?
indexterm.endofrange.zone.attrib = zone.attribute?

indexterm.singular.pagenum.attrib = pagenum.attribute?
indexterm.startofrange.pagenum.attrib =  pagenum.attribute?
indexterm.endofrange.pagenum.attrib =  pagenum.attribute?

indexterm.singular.scope.attrib = scope.attribute?
indexterm.startofrange.scope.attrib = scope.attribute?
indexterm.endofrange.scope.attrib = scope.attribute?

indexterm.singular.class.attrib = attribute class { "singular" }?
indexterm.startofrange.class.attrib = attribute class { "startofrange" }
indexterm.endofrange.class.attrib = attribute class { "endofrange" }

indexterm.endofrange.startref.attrib = attribute startref { xsd:IDREF }

indexterm.contentmodel =
   db.primary?,
   ((db.secondary,
      ((db.tertiary, (db.see | db.seealso+)?)
       | db.see
       | db.seealso+)?)
    | db.see
    | db.seealso+)?

indexterm.singular =
   element indexterm {
      indexterm.contentmodel
   }

indexterm.startofrange =
   element indexterm {
      indexterm.contentmodel
   }

indexterm.endofrange =
   element indexterm {
      indexterm.contentmodel
   }

db.indexterm = (indexterm.singular|indexterm.startofrange|indexterm.endofrange)

sortas.attribute = attribute sortas { text }?

primary.sortas.attrib = sortas.attribute?
db.primary = element primary { inlines* }

secondary.sortas.attrib = sortas.attribute?
db.secondary = element secondary { inlines* }

tertiary.sortas.attrib = sortas.attribute?
db.tertiary = element tertiary { inlines* }

db.see = element see { inlines* }

db.seealso = element seealso { inlines* }
