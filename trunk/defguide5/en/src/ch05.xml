<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns="http://docbook.org/ns/docbook"
         version="5.0"
         xml:id="app-customizing"
         xmlns:xlink="http://www.w3.org/1999/xlink">
<?dbhtml filename="ch05.html"?>
<info>
<title>Customizing DocBook</title>
<pubdate>$Date$</pubdate>
<releaseinfo>$Revision$</releaseinfo>
</info>
 
<para><indexterm significance="normal"><primary>customizing</primary>
  <secondary>DocBook schema</secondary></indexterm><indexterm significance="normal"><primary>DocBook schema</primary>
  <secondary>customizing</secondary>
</indexterm><indexterm significance="normal"><primary>attributes</primary>
  <secondary>DocBook schema, customizing</secondary>
</indexterm><indexterm significance="normal"><primary>elements</primary>
  <secondary>DocBook schema, customizing</secondary>
</indexterm>For some applications, DocBook <quote>out
of the box</quote> may not be exactly what you need. Perhaps you need
additional inline elements or perhaps you want to remove elements that
you never want your authors to use. By design, DocBook makes this sort
of customization easy.</para>
<para>
It is even easier to customize DocBook 5.0 than it was to customize
earlier releases. This is because DocBook 5.0 uses RELAX NG to
express its schema. RELAX NG provides better
support for modifications than DTDs, and the DocBook
schema takes full advantage of that support.
</para>
<para>This chapter describes the organization of the RELAX NG
schema for DocBook and how to make your own <firstterm>customization layer</firstterm>. It contains methods and examples for adding, removing, and
modifying elements and attributes, and conventions for naming and
versioning DocBook customizations. It assumes some familiarity with
RELAX NG. If you are unfamiliar with RELAX NG, you can find a tutorial
introduction in the <citetitle xlink:href="http://www.relaxng.org/tutorial-20011203.html">RELAX NG Tutorial</citetitle>.
</para>

<para><indexterm significance="normal"><primary>extensions, DocBook schema</primary>
</indexterm><indexterm significance="normal"><primary>environment</primary>
<secondary>DocBook extensions, affecting</secondary>
</indexterm>You can use customization layers to extend DocBook or
subset it. Creating a schema that is a strict subset
of DocBook means that all of your instances are still completely valid
DocBook instances, which may be important to your tools and
stylesheets, and to other people with whom you share documents. An
<firstterm>extension</firstterm> adds new structures, or changes the
schema in a way that is not compatible with DocBook.
Extensions can be very useful, but might have a great impact on your
environment.
</para>

<para>Customization layers can be as small as restricting an attribute
value or as large as adding an entirely different hierarchy on top of
the inline elements.
</para>

<section xml:id="ch05-shouldi"><info><title>Should You Do This?</title></info>

<para><indexterm significance="normal"><primary>stylesheets</primary>
  <secondary>schema extension, effects</secondary>
</indexterm>Changing a schema can have a wide-ranging
impact on the tools and stylesheets that you use. It can have an
impact on your authors and on your legacy documents. This is
especially true if you make an extension. If you rely on your support
staff to install and maintain your authoring and publishing tools,
check with them before you invest a lot of time modifying the
schema. There may be additional issues that are
outside your immediate control. Proceed with caution.
</para>

<para>That said, DocBook is designed to be easy to modify. This
chapter assumes that you are comfortable with
<acronym>XML</acronym> and RELAX NG grammar
syntax, but the examples presented should be a good springboard to
learning the syntax if it's not already familiar to you.
</para>
</section>

<section xml:id="s-notdocbook"><info><title>If You Change DocBook,
It's Not DocBook Anymore!</title></info>
<para>The license agreement under
which DocBook is distributed gives you complete freedom to change,
modify, reuse, and generally hack the schema in any way you want,
except that you must not call your alterations <quote>DocBook.</quote>
</para>
<section xml:id="s-dbversion">
<title>Namespace and Version</title>
<para>Starting with DocBook V5.0, DocBook is identified by its namespace,
<uri>http://docbook.org/ns/docbook</uri>. The particular version of
DocBook to which an element conforms is identified by its
<tag class="attribute">version</tag> attribute. If the element does not
specify a version, the version of the closest ancestor DocBook
element that does specify a version is assumed. The 
<tag class="attribute">version</tag> attribute is required on the root
DocBook element.</para>
<para>Here is how these attributes would appear on the <tag>book</tag> element.
</para>
<informalexample xml:id="ex.rootelement">
<programlisting language="xml"><![CDATA[<book xmlns="http://docbook.org/ns/docbook"
      version="5.0">
  …
</book>
]]></programlisting>
</informalexample>
<para>If you make any changes to the DocBook schema, the namespace
remains the same, but you must provide an alternative version
identifier for the schema and the modules you changed. The version
attribute identifies the version of DocBook the alternate is based on,
specifies what type of variant it is, and names the variant and any
additional modules. While the format for the version string is not
part of the normative specification, the DocBook Technical Committee
recommends the following format:</para>

<screen><replaceable>base_version</replaceable>-(subset|extension|variant) (<replaceable>name</replaceable>[-<replaceable>version</replaceable>])+</screen>

<para>For example, version 1.0 of Acme Corporation's extension of
DocBook V5.0 could be identified as
“<literal>5.0-extension acme-1.0</literal>”.</para>

<para>A document that relied on version 3.2 of Sample
Corporation's subset of DocBook V5.0, with MathML 2.0 and SVG 1.1, could be
identified as:
“<literal>5.0-subset Sample-3.2 mathml-2.0 svg-1.1</literal>”.</para>

<para>If your schema is a proper subset, use the
<literal>subset</literal> keyword in the version. If your schema
extends the markup model, use the <literal>extension</literal>
keyword. If you'd rather not characterize your variant specifically as
a subset or an extension, use the <literal>variant</literal> keyword.
</para>
</section>
<section xml:id="pubid">
<title>Public Identifiers</title>

<para><indexterm>
  <primary>public identifiers</primary>
  <secondary>DocBook</secondary>
  <tertiary>altering</tertiary> </indexterm>Although not directly
  supported by RELAX NG, in some cases it may still be valuable to
  identify a DocBook V5.0 customization layer with a public
  identifier.  A public identifier for DocBook V5.0 is:
</para>
<screen>-//OASIS//DTD DocBook V5.0//EN</screen>

<para><indexterm><primary>owner-identifiers</primary>
  <secondary>changing (DocBook customization)</secondary></indexterm>
  <indexterm><primary>description, changing (DocBook
  customization)</primary> </indexterm>If you make any changes to the
  structure of the schema, you must change the public identifier. You
  should change both the owner identifier and the description. Formal
  public identifiers for the base DocBook modules would have
  identifiers with the following syntax:
<screen>-//OASIS//<replaceable>text-class</replaceable> DocBook <replaceable>description</replaceable> V<replaceable>version</replaceable>//EN
</screen>
</para>
<para>
Your public identifiers should use the following syntax:
<screen>-//<replaceable>Owner-ID</replaceable>//<replaceable>text-class</replaceable> DocBook V<replaceable>version</replaceable>-Based (Subset|Extension|Variant) \
<replaceable>Description-and-version</replaceable>//<replaceable>lang</replaceable>
</screen>
</para>

<para>For example:
<screen>-//O'Reilly//DTD DocBook V5.0-Based Subset V1.1//EN
</screen>
</para>

<para><indexterm><primary>subsets (DocBook schema)</primary>
</indexterm>If your schema is a proper subset, use the
<literal>Subset</literal> keyword in the description. If your schema
extends the markup model, use the
<literal>Extension</literal> keyword. If you'd rather not characterize
your variant specifically as a subset or an extension, use the
<literal>Variant</literal> keyword.
</para>
</section>
</section>

<section xml:id="ch05-layers">
<info>
  <title>Customization Layers</title>
</info>

<para>A RELAX NG grammar is a collection of patterns. These patterns
can be stored in a single file or in a collection of files that import
each other. Patterns can augment each other in a variety of ways.
A complete grammar is the logical union of the specified patterns.</para>

<para>For convenience, the DocBook grammar is distributed in a single
file.</para>

<section xml:id="ch05-syntax">
<title>RELAX NG Syntax</title>

<para>There are two standard syntaxes for RELAX NG, an XML syntax and
a “compact” text syntax. The two forms have the same expressive power;
it is possible to transform between them with no loss of information.</para>

<para>Many users find the relative terseness of the compact syntax makes
it a convenient form for reading and writing RELAX NG. That is the form
we will use in the following examples.</para>
</section>

<section xml:id="ch05-patnames">
<title>DocBook Schema Structure</title>

<para>
The DocBook RELAX NG schema is highly modular, using named patterns
extensively. Every element, attribute, attribute list, and enumeration
has its own named pattern. In addition, there are named patterns for
logical combinations of elements and attributes. These named patterns
provide <quote>hooks</quote> into the schema that allow you to do a
wide range of customization by simply redefining one or more of the
named patterns.
</para>
<para>The names of the patterns used in a RELAX NG grammar can be defined
in any way the schema designer chooses. To make it easier to navigate,
the DocBook RELAX NG grammar employs the following naming
conventions:</para>

<variablelist>
<varlistentry>
<term><literal>db.<replaceable>*</replaceable>.attlist</literal></term>
<listitem>
<para>Defines the list of attributes associated with an element. For example,
<literal>db.emphasis.attlist</literal> is the pattern that matches all of the
attributes of the <tag>emphasis</tag> element.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>db.<replaceable>*</replaceable>.attribute</literal></term>
<listitem>
<para>Defines a single attribute. For example,
<literal>db.conformance.attribute</literal> is the pattern that matches
the <tag class="attribute">conformance</tag> attribute on all of the elements
where it occurs.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>db.<replaceable>*</replaceable>.attributes</literal></term>
<listitem>
<para>Defines a collection of attributes. For example,
<literal>db.effectivity.attributes</literal> is all of the effectivity
attributes (<tag class="attribute">arch</tag>,
<tag class="attribute">audience</tag>, etc.).</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>db.<replaceable>*</replaceable>.blocks</literal></term>
<listitem>
<para>Defines a list (a choice of) a set of related block elements.
For example, <literal>db.list.blocks</literal> is a pattern that matches
any of the list elements.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>db.<replaceable>*</replaceable>.contentmodel</literal></term>
<listitem>
<para>Defines a fragment of content model shared by several elements.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>db.<replaceable>*</replaceable>.enumeration</literal></term>
<listitem>
<para>Defines an enumeration, usually one used in an attribute value.
For example, <literal>db.revisionflag.enumeration</literal> is a pattern that
matches the list of values that can be used as the value of a
<tag class="attribute">revisionflag</tag> attribute.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>db.<replaceable>*</replaceable>.info</literal></term>
<listitem>
<para>Defines the <tag>info</tag> element for a particular element.
For example, <literal>db.example.info</literal> is the pattern that
matches <tag>info</tag> on <tag>example</tag>.</para>
<para>Almost all of the <tag>info</tag> elements are the same, but they
are described with distinct patterns so that customizers can change
them selectively.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>db.<replaceable>*</replaceable>.inlines</literal></term>
<listitem>
<para>Defines a list (a choice of) a set of related inline elements.
For example, <literal>db.link.inlines</literal> is a pattern that matches
any of the linking-related elements.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>db.<replaceable>*</replaceable>.role.attribute</literal></term>
<listitem>
<para>Defines the <tag class="attribute">role</tag> attribute for a particular
element. For example, <literal>db.emphasis.role</literal> is the pattern
that matches <tag class="attribute">role</tag> on <tag>emphasis</tag>.
</para>
<para>All of the <tag class="attribute">role</tag> attributes are the same, but they
are described with distinct patterns so that customizers can change
them selectively.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>db.<replaceable>*</replaceable></literal></term>
<listitem>
<para>Is the pattern that matches a particular DocBook element.
element. For example, <literal>db.title</literal> is the pattern
that matches <tag>title</tag>.
</para>
<para>RELAX NG allows multiple patterns to match the same element, so sometimes
these patterns come in flavors, for example,
<literal>db.indexterm.singular</literal>,
<literal>db.indexterm.startofrange</literal>, and
<literal>db.indexterm.endofrange</literal>. Each of these patterns matches
a <tag>indexterm</tag> with varying attributes.</para>
</listitem>
</varlistentry>
</variablelist>

<para>These are conventions, not hard and fast rules. There are patterns that
don't follow these conventions.</para>
</section>
<section xml:id="ch05-genstruct">
<title>The General Structure of Customization Layers</title>

<para><indexterm><primary>customizing</primary>
  <secondary>DocBook</secondary>
    <tertiary>structure (customization layers)</tertiary>
    </indexterm>Creating a customized schema is similar to creating a
customization layer for XSL. The schema customization layer is a
new RELAX NG schema that defines your changes and includes the
standard docbook schema. You then validate using the schema
customization as your schema.
Although customization layers vary in complexity, most of
them have the same general structure as other customization layers of
similar complexity.
</para>

<para>In the most common case, you probably want to include all of
DocBook, but you want to make some small changes. These customization
layers tend to look like this:
</para>

<screenco>
<areaspec>
<area xml:id="gs1-d1" coords="4 50" units="linecolumn"/>
<area xml:id="gs1-n1" coords="6 50" units="linecolumn"/>
</areaspec>
<screen><textobject>
<textdata fileref="examples/custlayer.rnc"/>
</textobject></screen>
<calloutlist>
<callout arearefs="gs1-d1"><para>Start by importing the base DocBook
schema.
</para></callout>
<callout arearefs="gs1-n1"><para>Then you can add new patterns or
augment existing patterns.
</para></callout>
</calloutlist>
</screenco>

<para>If you want to completely replace a pattern (for example, to
remove or completely change an element), the template is a little
different.</para>

<screenco>
<areaspec>
<area xml:id="gs2-d1" coords="5 50" units="linecolumn"/>
<area xml:id="gs2-n1" coords="8 50" units="linecolumn"/>
</areaspec>
<screen><textobject>
<textdata fileref="examples/custlayer2.rnc"/>
</textobject></screen>
<calloutlist>
<callout arearefs="gs2-d1"><para>You can redefine patterns in the
body of an import statement. These patterns completely replace any that
appear in the imported schema.
</para></callout>
<callout arearefs="gs2-n1"><para>As before, patterns outside the
include statement can augment existing patterns (even redefined ones).
</para></callout>
</calloutlist>
</screenco>

<para>There are other possibilities as well, these examples are
illustrative, not exhaustive.</para>
</section>
</section>

<section xml:id="ch05-write">
<title>Writing, Testing, and Using a Customization Layer</title>

<para><indexterm><primary>DocBook</primary>
  <secondary>customizing</secondary>
    <tertiary>customization layers, writing, testing, and using</tertiary>
</indexterm><indexterm><primary>customizing</primary>
  <secondary>DocBook</secondary>
    <tertiary>writing, testing and using customization layers</tertiary>
</indexterm>The procedure for creating, testing, and using a
customization layer is always about the same. In this section, we'll
go through the process in some detail. The rest of the sections in
this chapter describe a range of useful customization layers.
</para>

<section><title>Deciding What to Change</title>

<para>If you're considering writing a customization layer, there must be
something that you want to change. Perhaps you want to add an element
or attribute, remove one, or change some other aspect of the schema.
</para>

<para><indexterm><primary>inline elements</primary>
<secondary>adding</secondary>
</indexterm>Adding an element, particularly an inline element, is one
possibility. If you're writing about cryptography, you might want
to add a “<literal>cleartext</literal>” element, for example. The
next section describes how to create a customization layer to do this.
</para>
</section>

<section><title>Deciding How to Change a Customization Layer</title>

<para><indexterm><primary>customizing</primary>
<secondary>DocBook schema</secondary>
<tertiary>changing customization layers</tertiary>
</indexterm>Figuring out what to change may be the hardest part of
the process. For the <tag role="nonexistant">cleartext</tag> example, there are
several patterns that you could possibly change. The choice will
depend on the exact focus of your document. Here are several
candidates, all of which look plausible: technical inlines,
programming inlines, and domain inlines.  Let's suppose you chose
the domain inlines.
</para>

<para>As shown in <xref linkend="ex-addcleartext"/>, your
customization would import the DocBook schema, extend the domain
inlines, and then provide a pattern that matches the new element.
</para>

<example xml:id="ex-addcleartext">
<title>Adding <tag role="nonexistant">cleartext</tag> with a Customization Layer</title>
<programlistingco>
<areaspec>
<area xml:id="gs3-d1" coords="6 50" units="linecolumn"/>
<area xml:id="gs3-d1b" coords="8 50" units="linecolumn"/>
<area xml:id="gs3-d2" coords="10 57" units="linecolumn"/>
<area xml:id="gs3-d3" coords="11 50" units="linecolumn"/>
<area xml:id="gs3-d4" coords="16 50" units="linecolumn"/>
</areaspec>
<programlisting><textobject>
<textdata fileref="examples/addcleartext.rnc"/>
</textobject></programlisting>
<calloutlist>
<callout arearefs="gs3-d1"><para>The “<literal>|=</literal>” operator
adds a new choice to a pattern. So this line makes the
“<literal>db.cleartext</literal>” pattern a valid option anywhere that
“<literal>db.domain.inlines</literal>” appears.</para>
</callout>
<callout arearefs="gs3-d1b"><para>Next, we create a pattern for the
<literal>cleartext</literal> element. The convention in the DocBook
schema is to create three patterns, one for the role attribute, one
for the attributes, and one for the element. By following this convention,
we make it easier for someone to customize our customization.</para>
</callout>
<callout arearefs="gs3-d2"><para>Defining a separate pattern for the role
attribute makes it easy for customizers to change it on a per-element 
basis.</para>
</callout>
<callout arearefs="gs3-d3"><para>Defining a separate pattern for the attributes
makes it easy for customizers to change them on a per-element basis.
</para>
</callout>
<callout arearefs="gs3-d4"><para>The pattern for the element pulls it all
together. The pattern “<literal>db._text</literal>” matches text plus
a number of ubiquitous or nearly ubiquitous inlines. Use this pattern
unless you <emphasis>really</emphasis> want only text.</para>
</callout></calloutlist>
</programlistingco>
</example>
</section>

<section>
<title>Using Your Customization Layer</title>

<para><indexterm><primary>customizing</primary>
  <secondary>DocBook</secondary>
    <tertiary>writing, testing, and using customization layers</tertiary></indexterm>
<indexterm><primary>DocBook</primary>
  <secondary>customizing</secondary>
    <tertiary>using customization layer</tertiary> </indexterm>Using a
    customization layer is simple.  Just put the customization into a
    file, for example <filename>mycustomization.rnc</filename>, then
    refer to that file instead of the DocBook schema when your tools
    offer the option.
</para>
</section>

<section xml:id="cust.test">
<title>Testing Your Work</title>

<para><indexterm><primary>customizing</primary>
  <secondary>DocBook schema</secondary>
    <tertiary>writing, testing, and using customization layers</tertiary></indexterm>
<indexterm><primary>testing</primary>
  <secondary>customization layers (DocBook schema)</secondary></indexterm>
<indexterm><primary>validation</primary>
  <secondary>customization layers</secondary>
</indexterm>Schemas, by their nature, contain many complex,
interrelated patterns. Whenever you make a change to the schema, it's
always wise to use a validator to double-check your work.</para>

<para>Start by validating a document that's plain, vanilla DocBook, one
that you know is valid according to the DocBook standard schema. This
will help you identify errors that you've introduced to the schema itself.
After you are confident that the schema is correct, begin testing with
instances that you expect (and don't expect) to be valid against it.
</para>
<para>The following sections contain examples for several
common customizations.
</para>
</section>
</section>

<section xml:id="ch05-remvelem">
<title>Removing Elements</title>

<para><indexterm><primary>elements</primary>
  <secondary>removing</secondary>
</indexterm>DocBook has a large number of elements. In some authoring
environments, it may be useful or necessary to remove some of these
elements.
</para>

<section><title>Removing <tag>msgset</tag></title>

<para><indexterm><primary>msgset element</primary>
  <secondary>removing</secondary>
</indexterm><tag>MsgSet</tag> is a favorite target. It has a
complex internal structure designed for describing interrelated error
messages, especially on systems that may exhibit messages from several
different components. Many technical documents can do without it, and
removing it leaves one less complexity to explain to your authors.
</para>

<para><xref linkend="ex.remvmsgset"/> shows a customization layer that
removes the <tag>msgset</tag> element from DocBook:
</para>

<example xml:id="ex.remvmsgset">
<title>Removing <tag>msgset</tag></title>
<programlisting><textobject>
<textdata fileref="examples/remvmsgset.rnc"/>
</textobject></programlisting>
</example>

<para>The complexity of <tag>msgset</tag> is really in its <tag>msgentry</tag>
children. DocBook V4.5 introduced a simple alternative, <tag>simplemsgentry</tag>.
<xref linkend="ex.remvmsgentry"/> demonstrates how you could
allow <tag>msgset</tag> but only support the simpler
alternative.</para>

<example xml:id="ex.remvmsgentry">
<title>Removing <tag>msgentry</tag></title>
<programlisting><textobject>
<textdata fileref="examples/remvmsgentry.rnc"/>
</textobject></programlisting>
</example>

<para>Closer examination of the <tag>msgentry</tag> content model will
reveal that it contains a number of descendants. It isn't necessary, but it
wouldn't be wrong, to define their patterns as <literal>notAllowed</literal>
as well.</para>
</section>

<section><title>Removing Computer Inlines</title>

<para><indexterm><primary>inline elements</primary>
  <secondary>computer inlines, removing</secondary></indexterm>
<indexterm><primary>parameter entities</primary>
  <secondary>tech.char.class, redefining</secondary></indexterm>
<indexterm><primary>tech.char.class parameter entity</primary>
  <secondary>redefining</secondary>
</indexterm>DocBook contains a large number of computer inlines. The
DocBook inlines define a domain-specific vocabulary. If you're working
in another domain, many of them may be unnecessary.</para>

<para>They're defined in a set of patterns that ultimately roll-up to
the “<literal>db.domain.inlines</literal>” pattern. If you make that
pattern “<literal>notAllowed</literal>”, you'll remove them all in one
fell swoop.</para>

<example>
<title>Removing Computer Inlines</title>
<programlisting><textobject>
<textdata fileref="examples/remvdomain.rnc"/>
</textobject></programlisting>
</example>

<para>If you want to be more selective, you might consider making one
or more of the set not allowed instead:
“<literal>db.error.inlines</literal>”, errors and
error messages;
“<literal>db.gui.inlines</literal>”, GUI elements;
“<literal>db.keyboard.inlines</literal>”, key and keyboard elements;
“<literal>db.markup.inlines</literal>”, markup elements;
“<literal>db.math.inlines</literal>”, mathematical expressions;
“<literal>db.os.inlines</literal>”, operating system inlines; and
“<literal>db.programming.inlines</literal>”, programming-related inlines.</para>

<para><indexterm><primary>synopses</primary>
  <secondary>synopsis elements, removing</secondary></indexterm>
<indexterm><primary>funcsynopsis element</primary>
  <secondary>removing</secondary></indexterm>
<indexterm><primary>cmdsynopsis element</primary>
  <secondary>removing</secondary>
</indexterm>It's likely that a customization layer that removed this
many technical inlines would also remove some larger technical
structures (<tag>msgset</tag>, <tag>funcsynopsis</tag>).</para>
</section>

<section>
<title>Removing Synopsis Elements</title>

<para>Another possibility is removing the complex synopsis elements.
The customization layer in <xref linkend="ex.remvcmdsyn"/> removes
<tag>cmdsynopsis</tag> and <tag>funcsynopsis</tag>.
</para>

<example xml:id="ex.remvcmdsyn">
<title>Removing CmdSynopsis and FuncSynopsis</title>
<programlisting><textobject>
<textdata fileref="examples/remvcmdsyn.rnc"/>
</textobject></programlisting>
</example>
</section>

<section>
<title>Removing Sectioning Elements</title>

<para><indexterm><primary>sections</primary>
  <secondary>elements, removing</secondary>
</indexterm>Perhaps you want to restrict your authors to only three
levels of sectioning. To do that, you must remove the <tag>sect4</tag>
and <tag>sect5</tag> elements, as shown in <xref
linkend="ex.remvsect4"/>.</para>

<example xml:id="ex.remvsect4">
<title>Removing <tag>sect4</tag> and <tag>sect5</tag> Elements
</title>
<programlisting><textobject>
<textdata fileref="examples/remvsect4.rnc"/>
</textobject></programlisting>
</example>

<para>This technique works if your authors are using numbered sections.
You could require them to do so by removing <tag>section</tag>. But
suppose instead you want to allow them to use recursive sections and
still limit them to only three levels.</para>

<para>One way to do this would be to define new “<literal>section2</literal>”
and “<literal>section3</literal>” patterns, as shown in
<xref linkend="ex.limitsdepth"/>.</para>

<example xml:id="ex.limitsdepth">
<title>Limiting recursive sections to three levels</title>
<programlisting><textobject>
<textdata fileref="examples/limitsdepth.rnc"/>
</textobject></programlisting>
</example>

<para>Another solution, assuming your validation environment supports
Schematron, is simply to add a new rule,  as shown in
<xref linkend="ex.limitsdepthsch"/>.</para>

<example xml:id="ex.limitsdepthsch">
<title>Limiting recursive sections to three levels</title>
<programlisting><textobject>
<textdata fileref="examples/limitsdepthsch.rnc"/>
</textobject></programlisting>
</example>

</section>

<section xml:id="s2-remvadmon">
<title>Removing Admonitions from Table Entries</title>

<para><indexterm><primary>modules</primary>
  <secondary>redeclarations</secondary></indexterm>
<indexterm><primary>redeclarations</primary>
  <secondary>modules</secondary>
</indexterm>Sometimes what you want to do is not as simple as entirely
removing an element. Instead, you want to remove it only from some
contexts. The way to accomplish this task is to redefine the patterns
used to calculate the elements allowed in those contexts.</para>

<para>Standard DocBook allows any inline element or any block element
to appear in a table cell. You might decide that it's unreasonable to
allow admonitions (<tag>note</tag>, <tag>caution</tag>, <tag>warning</tag>,
etc.) to appear in a table cell.</para>

<para>In order to remove them, you must change what is allowed in an
<tag>entry</tag>, as show in 
<xref linkend="ex.remvadmon"/>.</para>

<example xml:id="ex.remvadmon">
<title>Removing Admonitions from Tables</title>
<programlisting><textobject>
<textdata fileref="examples/remvadmon.rnc"/>
</textobject></programlisting>
</example>

<para>The extent to which any particular change is easy or hard
depends in part on how many patterns need to be changed. The DocBook
Technical Committee is generally open to the idea of adding more
patterns if it improves the readability of customization layers. If
you think some refactoring would make your job easier, feel free to ask.</para>
</section>
</section>

<section xml:id="ch05-remvattr">
<title>Removing Attributes</title>

<para>Just as there may be more elements than you need, there may be more
attributes.</para>

<para><indexterm><primary>attributes</primary>
  <secondary>removing</secondary></indexterm>
<indexterm><primary>continues attribute, removing</primary>
</indexterm>Suppose your processing system doesn't support “continued”
lists. You want to remove the
<tag class="attribute">continuation</tag> attribute from the
<tag>orderedlist</tag>
element. There are two ways you could accomplish this. One way would be
to redefine the “<literal>db.orderedlist.continuation.attribute</literal>”
as not allowed; the other would be to redefine the
“<literal>db.orderedlist.attlist</literal>” pattern so that it does not
include the continuation attribute. Either would accomplish the goal.
<xref linkend="ex.remvcontinuation"/> uses the first method.
</para>

<example xml:id="ex.remvcontinuation">
<title>Removing <tag class="attribute">continuations</tag> from
<tag>orderedlist</tag></title>
<programlisting><textobject>
<textdata fileref="examples/remvcontinuation.rnc"/>
</textobject></programlisting>
</example>

<section><title>Subsetting the Common Attributes</title>

<para><indexterm><primary>attributes</primary>
  <secondary>common</secondary>
    <tertiary>subsetting</tertiary></indexterm>
<indexterm><primary>subsetting common attributes</primary>
</indexterm>DocBook defines a whole set of “common attributes”; these attributes
appear on <emphasis>every</emphasis> element. Depending on how you're
processing your documents, removing some of them can both simplify the
authoring task and improve processing speed.
</para>
<para>Some obvious candidates are:</para>
<variablelist>
<varlistentry><term>Effectivity attributes (<tag class="attribute">Arch
</tag>, <tag class="attribute">OS</tag>,...)</term>
<listitem>
<para>
<indexterm><primary>effectivity attributes, removing</primary></indexterm>

If you're not using all of the effectivity attributes in your
documents, you can get rid of up to seven attributes in one fell
swoop.</para>
</listitem>
</varlistentry>
<varlistentry><term><tag class="attribute">lang</tag></term>
<listitem>
<para>
<indexterm><primary>lang attribute</primary>
  <secondary>removing</secondary>
</indexterm>If you're not producing multilingual documents, you can remove
<tag class="attribute">lang</tag>.</para>
</listitem>
</varlistentry>
<varlistentry><term><tag class="attribute">remap</tag></term>
<listitem>
<para>
<indexterm><primary>remap attribute</primary>
  <secondary>removing</secondary>
</indexterm>The <tag class="attribute">remap</tag> attribute is
designed to hold the name of a semantically equivalent construct from
a previous markup scheme (for example, a Microsoft Word style template
name, if you're converting from Word). If you're authoring from
scratch, or not preserving previous constructs with <tag
class="attribute">remap</tag>, you can get rid of it.</para>
</listitem>
</varlistentry>
<varlistentry><term><tag class="attribute">xreflabel</tag></term>
<listitem>
<para>
<indexterm><primary>xreflabel attribute</primary>
  <secondary>removing</secondary>
</indexterm>If your processing system isn't using
<tag class="attribute">xreflabel</tag>, it's a candidate as well.</para>
</listitem>
</varlistentry>
</variablelist>

<para>The customization layer in <xref linkend="ex.remvcommon"/>
reduces the common attributes to just <tag class="attribute">xml:id</tag>
<tag class="attribute">version</tag>,
and <tag class="attribute">lang</tag>.
</para>

<example xml:id="ex.remvcommon">
<title>Removing Common Attributes</title>
<programlisting><textobject>
<textdata fileref="examples/remvcommon.rnc"/>
</textobject></programlisting>
</example>
<!-- Seems like this is orphaned or out of context.
<para>The <tag class="attribute">xml:id</tag> attribute is added in two
other patterns, one where it's required and one where it's optional.</para>
-->
</section>
</section>

<section xml:id="ch05-addelem">
<title>Adding Elements</title>

<para><indexterm><primary>elements</primary>
  <secondary>adding</secondary>
</indexterm>Adding a new inline or block element is generally a
straightforward matter of creating a pattern for the new element and
“<literal>|=</literal>” adding it to the right pattern, as we did in
<xref linkend="ex-addcleartext"/>. But if your new element is more
intimately related to the existing structure of the document, it may
require more surgery.</para>

<para><xref linkend="ex.addsect6"/>
extends DocBook by adding a <literal>sect6</literal> element.
</para>

<example xml:id="ex.addsect6">
<title>Adding a <literal>sect6</literal> Element</title>
<programlisting><textobject>
<textdata fileref="examples/addsect6.rnc"/>
</textobject></programlisting>
</example>

<para>Here we've redefined <tag>sect5</tag> to include
<literal>sect6</literal> and provided a pattern for
<literal>sect6</literal>.
</para>
</section>
<section xml:id="ch05-addattribute">
  <title>Adding Attributes</title>
<para><indexterm><primary>attributes</primary>
<secondary>adding</secondary> </indexterm>The simplest way to add an
attribute to a single element is to add it to the attlist pattern for
that element. <xref linkend="ex.addattribute"/> adds the optional
attributes <tag class="attribute">born</tag> and <tag
class="attribute">died</tag> to the attribute list for <tag>author</tag>. The
<literal>db.author.attlist</literal> pattern is redefined to interleave the two new
optional attributes with the existing attributes on the list.
  
</para>
<example xml:id="ex.addattribute">
<title>Adding <literal>born</literal> and <literal>died</literal> Attributes</title>
<programlistingco>
<areaspec>
  <area xml:id="exarea-a1" coords="6 50" units="linecolumn"/>
  <area xml:id="exarea-a2" coords="7 50" units="linecolumn"/>
</areaspec>
<programlisting><textobject>
<textdata fileref="examples/addattribute.rnc"/>
</textobject></programlisting>
<calloutlist>
<callout
arearefs="exarea-a1"><para><quote><literal>&amp;=</literal></quote>
interleaves the two new optional attributes with the existing
attributes on the list.</para></callout>
<callout
arearefs="exarea-a2"><para><literal>db.date.contentmodel</literal> is a pattern used for any attribute or element that represents a date.</para></callout>
</calloutlist>
</programlistingco>
</example>

</section>
<section xml:id="ch05-classrole">
<title>Other Modifications</title>
<section>
<title>Changing the Contents of the <tag class="attribute">role</tag> Attribute</title>
<para><indexterm><primary>role attribute</primary>
  <secondary>changing on procedure (example)</secondary>
</indexterm>The <tag class="attribute">role</tag> attribute, found on
almost all of the elements in DocBook, is a text
attribute that can be used to subclass an element. In some
applications, it may be useful to modify the definition of
<tag class="attribute">role</tag> so that authors must choose one of a
specific set of possible values.</para>

<para>In <xref linkend="ex.changerole"/>,
<tag class="attribute">role</tag> on the <tag>procedure</tag> element
is constrained to the values <literal>required</literal> or
<literal>optional</literal>.</para>

<example xml:id="ex.changerole">
<title>Changing role on <tag>procedure</tag></title>
<programlisting>
<textobject>
<textdata fileref="examples/changerole.rnc"/>
</textobject></programlisting>
</example>
</section>
<section>
<title>Adding a Value to an Enumerated Attribute</title>
<para><indexterm><primary>attribute</primary>
  <secondary>adding a value to an enumeration</secondary>
  </indexterm><xref linkend="ex.addenumeration"/> modifies
  <varname>db.spacing.enumeration</varname> to add the value
  <quote>large.</quote> Any attribute that is defined using
  <varname>db.spacing.enumeration</varname> will now have <tag
  class="attvalue">large</tag> as a legal value. Note that while it is
  easy to add a value to an enumeration, to remove a value from an
  enumeration, you need to redefine the entire enumeration, minus the
  values you don't need.
</para>
<example xml:id="ex.addenumeration">
<title>Adding a Value to an Enumeration</title>
<programlisting>
<textobject>
<textdata fileref="examples/addenumeration.rnc"/>
</textobject></programlisting>
</example>
</section>

</section>
</chapter>

