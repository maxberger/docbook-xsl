<article xmlns:src="http://nwalsh.com/xmlns/litprog/fragment"
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<title>Weave.xsl</title>

<src:topfragment id="top" default-exclude-result-prefixes="xsl">
<src:passthrough>
&lt;!DOCTYPE xsl:stylesheet [
&lt;!ENTITY nl "&lt;xsl:text>&#xA;&lt;/xsl:text>">
]>
</src:passthrough>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:src="http://nwalsh.com/xmlns/litprog/fragment"
                exclude-result-prefixes="xsl src xml"
                version="1.0">

  <xsl:include href="VERSION"/>

  <src:fragref linkend="space"/>
  <src:fragref linkend="param.ex.result.prefixes"/>
  <src:fragref linkend="root.template"/>
  <src:fragref linkend="default.template"/>
  <src:fragref linkend="topfragment"/>
  <src:fragref linkend="fragment"/>

  <src:fragref linkend="rest"/>
</xsl:stylesheet>
</src:topfragment>

<section><title>Whitespace Control</title>

<src:fragment id="space">
<xsl:preserve-space elements="*"/>
</src:fragment>

</section>

<section><title>Default Exclude Result Prefixes</title>

<src:fragment id="param.ex.result.prefixes">
<xsl:param name="default-exclude-result-prefixes"
           select="//src:topfragment/@default-exclude-result-prefixes"/>
</src:fragment>

</section>
<section><title>Root Template</title>

<src:fragment id="root.template">
<xsl:template match="/">
  <xsl:text>&#xA;</xsl:text>
  <xsl:comment>
    <xsl:text> This file was generated by weave.xsl version </xsl:text>
    <xsl:value-of select="$VERSION"/>
    <xsl:text>. Do not edit! </xsl:text>
  </xsl:comment>
  <xsl:text>&#xA;</xsl:text>
  <xsl:comment> See http://sourceforge.net/projects/docbook/ </xsl:comment>
  <xsl:apply-templates/>
</xsl:template>
</src:fragment>

</section>
<section><title>Default Template</title>

<src:fragment id="default.template">
<xsl:template match="*">
  <xsl:variable name="node" select="."/>
  <xsl:element name="{name(.)}" namespace="{namespace-uri(.)}">
    <xsl:for-each select="namespace::*">
      <xsl:if test="string(.) != namespace-uri($node)">
        <xsl:copy/>
      </xsl:if>
    </xsl:for-each>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates/>
  </xsl:element>
</xsl:template>
</src:fragment>

</section>
<section><title>Fragments</title>

<src:fragment id="topfragment">
<xsl:template match="src:topfragment">
  <src:fragment id="{@id}">
    <xsl:choose>
      <xsl:when test="node()[1] = '&#xA;'">
        <xsl:apply-templates select="node()[position()&gt;1 and position()&lt;last()]" mode="copy"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="node()[position()&lt;last()]" mode="copy"/>
      </xsl:otherwise>
    </xsl:choose>
  </src:fragment>
</xsl:template>
</src:fragment>

<src:fragment id="fragment">
<xsl:template match="src:fragment">
  <src:fragment id="{@id}">
    <xsl:choose>
      <xsl:when test="node()[1] = '&#xA;'">
        <xsl:apply-templates select="node()[position()&gt;1]" mode="copy"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="node()" mode="copy"/>
      </xsl:otherwise>
    </xsl:choose>
  </src:fragment>
</xsl:template>
</src:fragment>

</section>
<section><title>Rest</title>

<src:fragment id="rest">

<!-- ============================================================ -->

<xsl:template match="src:fragref">
  <xsl:variable name="linkend" select="@linkend"/>
  <src:fragref linkend="{@linkend}" disable-output-escaping="yes">
    <xsl:apply-templates/>
  </src:fragref>
</xsl:template>

<!-- ============================================================ -->

<xsl:template match="*" mode="copy" priority="2">
  <xsl:variable name="name" select="name(.)"/>
  <xsl:variable name="prevtext" select="preceding-sibling::text()"/>
  <xsl:variable name="exclude">
    <xsl:choose>
      <xsl:when test="ancestor::src:fragment/@exclude-result-prefixes">
        <xsl:value-of select="concat(' xml ',
                              ancestor::src:fragment/@exclude-result-prefixes,
                              ' ')"/>
      </xsl:when>
      <xsl:when test="ancestor::src:topfragment">
        <xsl:value-of select="concat(' xml ',
                              ancestor::src:top-fragment/@exclude-result-prefixes,
                              ' ')"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="concat(' xml ',
                              $default-exclude-result-prefixes,
                              ' ')"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:text>&lt;</xsl:text>
  <xsl:value-of select="name(.)"/>

  <xsl:variable name="applicable.namespaces">
    <xsl:call-template name="count.applicable.namespaces">
      <xsl:with-param name="namespaces" select="namespace::*"/>
      <xsl:with-param name="exclude-prefixes" select="$exclude"/>
      <xsl:with-param name="exclude-uri"
                      select="'http://nwalsh.com/xmlns/litprog/fragment'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:if test="$applicable.namespaces &gt; 0">
    <xsl:call-template name="output.applicable.namespaces">
      <xsl:with-param name="namespaces" select="namespace::*"/>
      <xsl:with-param name="exclude-prefixes" select="$exclude"/>
      <xsl:with-param name="exclude-uri"
                      select="'http://nwalsh.com/xmlns/litprog/fragment'"/>
    </xsl:call-template>
  </xsl:if>

  <xsl:choose>
    <xsl:when test="$applicable.namespaces &gt; 0">
      <xsl:call-template name="output.applicable.attributes">
        <xsl:with-param name="attributes" select="attribute::*"/>
        <xsl:with-param name="first" select="'0'"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="output.applicable.attributes">
        <xsl:with-param name="attributes" select="attribute::*"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>

  <xsl:text>&gt;</xsl:text>
  <xsl:apply-templates select="node()" mode="copy"/>
  <xsl:text>&lt;/</xsl:text>
  <xsl:value-of select="name(.)"/>
  <xsl:text>&gt;</xsl:text>
</xsl:template>

<xsl:template match="src:passthrough" mode="copy" priority="3">
  <xsl:apply-templates select="node()|@*" mode="copy"/>
</xsl:template>

<xsl:template match="src:comment" mode="copy" priority="3">
  <xsl:text>&lt;!--</xsl:text>
    <xsl:apply-templates select="node()|@*" mode="copy"/>
  <xsl:text>--&gt;</xsl:text>
</xsl:template>

<xsl:template match="src:fragref" mode="copy" priority="3">
  <xsl:variable name="linkend" select="@linkend"/>
  <xsl:choose>
    <xsl:when test="@disable-output-escaping='yes'">
      <xsl:text>&lt;src:fragref linkend="</xsl:text>
      <xsl:value-of select="@linkend"/>
      <xsl:text>"/&gt;</xsl:text>
      <xsl:apply-templates mode="copy"/>
      <xsl:text>&lt;/src:fragref&gt;</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xref linkend="{@linkend}"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="indent">
  <xsl:param name="name" select="name(.)"/>
  <xsl:param name="prevtext" select="preceding-sibling::text()"/>

  <xsl:variable name="namelen" select="string-length($name)"/>
  <xsl:call-template name="spaces">
    <xsl:with-param name="count" select="$namelen + 1"/>
  </xsl:call-template>
</xsl:template>

<xsl:template name="spaces">
  <xsl:param name="count" select="'0'"/>
  <xsl:if test="$count &gt; 0">
    <xsl:text> </xsl:text>
    <xsl:call-template name="spaces">
      <xsl:with-param name="count" select="$count - 1"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template>

<xsl:template name="count.applicable.namespaces">
  <xsl:param name="namespaces" select="namespace::*"/>
  <xsl:param name="exclude-prefixes" select="''"/>
  <xsl:param name="exclude-uri"
             select="'http://nwalsh.com/xmlns/litprog/fragment'"/>
  <xsl:param name="count" select="'0'"/>

<!--
  <xsl:message>
    <xsl:text>ns: </xsl:text>
    <xsl:value-of select="name(.)"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="$count"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="count($namespaces)"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="name($namespaces[1])"/>
    <xsl:text>=</xsl:text>
    <xsl:value-of select="$namespaces[1]"/>
    <xsl:choose>
      <xsl:when test="not(contains($exclude-prefixes, name($namespaces[1]))
                      or ($namespaces[1] = $exclude-uri))"> 1</xsl:when>
      <xsl:otherwise> 0</xsl:otherwise>
    </xsl:choose>
  </xsl:message>
-->

  <xsl:choose>
    <xsl:when test="count($namespaces) = 0">
      <xsl:value-of select="$count"/>
    </xsl:when>

    <xsl:when test="not(contains($exclude-prefixes, name($namespaces[1]))
                        or ($namespaces[1] = $exclude-uri))">
      <xsl:call-template name="count.applicable.namespaces">
        <xsl:with-param name="namespaces"
                        select="$namespaces[position()&gt;1]"/>
        <xsl:with-param name="exclude-prefixes" select="$exclude-prefixes"/>
        <xsl:with-param name="exclude-uri" select="$exclude-uri"/>
        <xsl:with-param name="count" select="$count + 1"/>
      </xsl:call-template>
    </xsl:when>

    <xsl:otherwise>
      <xsl:call-template name="count.applicable.namespaces">
        <xsl:with-param name="namespaces"
                        select="$namespaces[position()&gt;1]"/>
        <xsl:with-param name="exclude-prefixes" select="$exclude-prefixes"/>
        <xsl:with-param name="exclude-uri" select="$exclude-uri"/>
        <xsl:with-param name="count" select="$count"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="output.applicable.namespaces">
  <xsl:param name="namespaces" select="namespace::*"/>
  <xsl:param name="exclude-prefixes" select="''"/>
  <xsl:param name="exclude-uri"
             select="'http://nwalsh.com/xmlns/litprog/fragment'"/>
  <xsl:param name="first" select="'1'"/>

<!--
  <xsl:message>
    <xsl:text>ons: </xsl:text>
    <xsl:value-of select="name(.)"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="$first"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="count($namespaces)"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="name($namespaces[1])"/>
    <xsl:text>=</xsl:text>
    <xsl:value-of select="$namespaces[1]"/>
    <xsl:choose>
      <xsl:when test="not(contains($exclude-prefixes, name($namespaces[1]))
                      or ($namespaces[1] = $exclude-uri))"> 1</xsl:when>
      <xsl:otherwise> 0</xsl:otherwise>
    </xsl:choose>
  </xsl:message>
-->

  <xsl:choose>
    <xsl:when test="count($namespaces) = 0"/>
    <xsl:when test="not(contains($exclude-prefixes, name($namespaces[1]))
                        or ($namespaces[1] = $exclude-uri))">
      <xsl:choose>
        <xsl:when test="$first = 0">
          <xsl:text>&#xA;</xsl:text>
          <xsl:call-template name="indent"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text> </xsl:text>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:text>xmlns</xsl:text>
      <xsl:if test="name($namespaces[1]) != ''">:</xsl:if>
      <xsl:value-of select="name($namespaces[1])"/>
      <xsl:text>="</xsl:text>
      <xsl:value-of select="$namespaces[1]"/>
      <xsl:text>"</xsl:text>
      <xsl:call-template name="output.applicable.namespaces">
        <xsl:with-param name="namespaces"
                        select="$namespaces[position()&gt;1]"/>
        <xsl:with-param name="exclude-prefixes" select="$exclude-prefixes"/>
        <xsl:with-param name="exclude-uri" select="$exclude-uri"/>
        <xsl:with-param name="first" select="0"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="output.applicable.namespaces">
        <xsl:with-param name="namespaces"
                        select="$namespaces[position()&gt;1]"/>
        <xsl:with-param name="exclude-prefixes" select="$exclude-prefixes"/>
        <xsl:with-param name="exclude-uri" select="$exclude-uri"/>
        <xsl:with-param name="count" select="$first"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="output.applicable.attributes">
  <xsl:param name="attributes" select="attribute::*"/>
  <xsl:param name="first" select="'1'"/>

<!--
  <xsl:message>
    <xsl:text>att: </xsl:text>
    <xsl:value-of select="$first"/>
    <xsl:value-of select="count($attributes)"/>
    <xsl:value-of select="name($attributes[1])"/>
  </xsl:message>
-->

  <xsl:choose>
    <xsl:when test="count($attributes) = 0"/>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="$first = 0">
          <xsl:text>&#xA;</xsl:text>
          <xsl:call-template name="indent"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text> </xsl:text>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:value-of select="name($attributes[1])"/>
      <xsl:text>="</xsl:text>
      <xsl:value-of select="$attributes[1]"/>
      <xsl:text>"</xsl:text>
      <xsl:call-template name="output.applicable.attributes">
        <xsl:with-param name="attributes"
                        select="$attributes[position()&gt;1]"/>
        <xsl:with-param name="first" select="'0'"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="node()|@*" mode="copy">
  <xsl:copy>
    <xsl:apply-templates select="@*|node()" mode="copy"/>
  </xsl:copy>
</xsl:template>

<!-- ============================================================ -->
</src:fragment>

</section>

</article>
