<?xml version="1.0"?>
<bindings xmlns="http://www.mozilla.org/xbl"
     xmlns:html="http://www.w3.org/1999/xhtml">

  <binding id="ulink">
    <handlers>
      <handler event="click" button="0"
               action="window.location=this.attributes.url.value;"/>
      <handler event="mouseover"
               action="window.status=this.attributes.url.value;"/>
      <handler event="mouseout"
               action="window.status=null;"/>
    </handlers>
  </binding>

  <!--
    Binding for <xref>

    This binding both creates content for the <xref>, and defines its behaviour
    as a UI element.

    Current implementation relies on getElementById() for content genetration,
    which will usually not work, since Mozilla browsers don't use the DTD.
  -->
  <binding id="xref">

    <!-- This span is used to hold the content generated by the constructor -->
    <content>
      <html:span/>
    </content>


    <handlers>
      <!--
	I had a complicated action for "click", implemented with
	window.scrollTo().  This is *much* nicer, being simpler and making
	the back button work as expected.
      -->
      <handler event="click" button="0"
               action="window.location.hash = this.attributes.linkend.value"/>
      <handler event="mouseover"
               action="window.status=this.attributes.linkend.value;"/>
      <handler event="mouseout"
               action="window.status=null;"/>
    </handlers>

    <implementation>
      <constructor><![CDATA[
	var node = document.getAnonymousNodes(this)[0];
	var child = document.createTextNode(generateXrefText());
	var f = function() { node.appendChild(child); }
	setTimeout(f, 0);
      ]]></constructor>

      <method name="generateXrefText">
	<body><![CDATA[
	  if (this.attributes.endterm) {
	    var node = document.getElementById(this.attributes.endterm.value);
	    return node.textContent;
	  }
	  var targetNode = this.findLinkend();
	  if (targetNode == null) {
	    return this.attributes.linkend.value;
	  }
	  if (targetNode.attributes.xreflabel) {
	    return targetNode.attributes.xreflabel.value;
	  }
	  if (targetNode.getElementsByTagName('title')[0]) {
	    return targetNode.getElementsByTagName('title')[0].textContent;
	  }
	  return this.attributes.linkend.value;
	]]></body>
      </method>

      <method name="findLinkend">
	<body><![CDATA[
	  return document.getElementById(this.attributes.linkend.value);
	]]></body>
      </method>
    </implementation>
  </binding>

  <!--
    Binding for <link>
  -->
  <binding id="link">
    <handlers>
      <handler event="click" button="0"
               action="window.location.hash = this.attributes.linkend.value"/>
      <handler event="mouseover"
               action="window.status='#'+this.attributes.linkend.value;"/>
      <handler event="mouseout"
               action="window.status=null;"/>
    </handlers>
  </binding>

  <binding id="mediaobj" inheritstyle="false">
    <!--
      We must have <children/> here, because Moz will reject this binding if
      any of the bound node's children aren't matched.
      Because of this, the stylesheet hides most of [inline]mediaobject's
      children with display:none;
    -->
    <content>
      <html:img/>
      <children/>
    </content>

    <implementation>
      <constructor>
	var img = document.getAnonymousNodes(this)[0];
	var file = this.selectImage();
	// HACK: using img.src=file 'inline' doesn't seem to work
	//       but it does when called from a setTimeout()
	var f = function() { img.src = file; }
	setTimeout(f, 0);
      </constructor>

      <method name="selectImage">
	<body><![CDATA[
	  var src = this.selectImageByRole();
	  if (src == null) {
	    src = this.selectImageByFormat()
	  }
	  if (src == null) {
	    src = "resource://gre/res/broken-image.gif";
	  }
	  return src;
	]]></body>
      </method>
      <method name="selectImageByRole">
	<body><![CDATA[
	  var fileref = document.evaluate("imageobject[@role='html' or @role='HTML' or @role='xhtml' or @role='XHTML']/imagedata/@fileref", this, null, XPathResult.STRING_TYPE, null).stringValue;
	  if (fileref != "") {
	    return fileref;
	  }
	  return null;
	]]></body>
      </method>
      <method name="selectImageByFormat">
	<body><![CDATA[
	  var fileref = document.evaluate("imageobject/imagedata[@format='PNG' or @format='GIF' or @format='GIF87a' or @format='GIF89a' or @format='JPG' or @format='JPEG']/@fileref", this, null, XPathResult.STRING_TYPE, null).stringValue;
	  if (fileref != "") {
	    return fileref;
	  }
	  return null;
	]]></body>
      </method>
    </implementation>
  </binding>
</bindings>
<!--
vim:softtabstop=2:shiftwidth=2
-->
